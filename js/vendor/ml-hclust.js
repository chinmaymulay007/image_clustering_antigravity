/**
 * Bundled by jsDelivr using Rollup v2.79.2 and Terser v5.39.0.
 * Original file: /npm/ml-hclust@3.1.0/src/index.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import { euclidean as e } from "./ml-distance-euclidean.js"; import t from "./ml-distance-matrix.js"; import { Matrix as r } from "./ml-matrix.js"; import n from "./heap.js"; class s { constructor() { this.children = [], this.height = 0, this.size = 1, this.index = -1, this.isLeaf = !1 } cut(e) { if ("number" != typeof e) throw new TypeError("threshold must be a number"); if (e < 0) throw new RangeError("threshold must be a positive number"); let t = [this]; const r = []; for (; t.length > 0;) { const n = t.shift(); e >= n.height ? r.push(n) : t = t.concat(n.children) } return r } group(e) { if (!Number.isInteger(e) || e < 1) throw new RangeError("groups must be a positive integer"); const t = new n(((e, t) => t.height - e.height)); for (t.push(this); t.size() < e;) { const e = t.pop(); if (0 === e.children.length) break; e.children.forEach((e => t.push(e))) } const r = new s; return r.children = t.toArray(), r.height = this.height, r } traverse(e) { !function e(t, r) { if (r(t), t.children) for (const n of t.children) e(n, r) }(this, e) } indices() { const e = []; return this.traverse((t => { t.isLeaf && e.push(t.index) })), e } } function i(e, t) { return Math.min(e, t) } function o(e, t) { return Math.max(e, t) } function c(e, t, r, n, s) { return n / (n + s) * e + s / (n + s) * t } function a(e, t) { return (e + t) / 2 } function h(e, t, r, n, s) { return n / (n + s) * e + s / (n + s) * t + -n * s / (n + s) ** 2 * r } function u(e, t, r) { return e / 2 + t / 2 - r / 4 } function f(e, t, r, n, s, i) { return (n + i) / (n + s + i) * e + (s + i) / (n + s + i) * t + -i / (n + s + i) * r } function m(e, t, r, n, s, i) { const o = (n + i) / (n + s + i), c = (s + i) / (n + s + i), a = -i / (n + s + i); return Math.sqrt(o * e * e + c * t * t + a * r * r) } function l(n, l = {}) { const { distanceFunction: w = e, method: d = "complete", isDistanceMatrix: b = !1 } = l; let k; b || (n = t(n, w)); let x = new r(n); const z = x.rows; if ("string" == typeof d) switch (d.toLowerCase()) { case "single": k = i; break; case "complete": k = o; break; case "average": case "upgma": k = c; break; case "wpgma": k = a; break; case "centroid": case "upgmc": k = h; break; case "median": case "wpgmc": k = u; break; case "ward": k = f; break; case "ward2": k = m; break; default: throw new RangeError(`unknown clustering method: ${d}`) } else if ("function" != typeof d) throw new TypeError("method must be a string or function"); let y = []; for (let e = 0; e < z; e++) { const t = new s; t.isLeaf = !0, t.index = e, y.push(t) } for (let e = 0; e < z - 1; e++) { const [e, t, n] = p(x), i = y[e], o = y[t], c = new s; c.size = i.size + o.size, c.children.push(i, o), c.height = n; const a = [c], h = new r(x.rows - 1, x.rows - 1), u = r => g(r, Math.min(e, t), Math.max(e, t)); for (let r = 1; r < h.rows; r++) { const s = u(r), c = y[s]; a.push(c); for (let a = 0; a < r; a++)if (0 === a) { const u = k(x.get(e, s), x.get(s, t), n, i.size, o.size, c.size); h.set(r, a, u), h.set(a, r, u) } else { const e = x.get(s, u(a)); h.set(r, a, e), h.set(a, r, e) } } y = a, x = h } return y[0] } function p(e) { let t = 1 / 0, r = 0, n = 0; for (let s = 1; s < e.rows; s++)for (let i = 0; i < s; i++)e.get(s, i) < t && (t = e.get(s, i), r = s, n = i); return [r, n, t] } function g(e, t, r) { return (e -= 1) >= t && e++, e >= r && e++, e } export { s as Cluster, l as agnes }; export default null;
//# sourceMappingURL=/sm/040b017e293d28de3cd840352336e5bf8eb08a2091f03643c6e5bed88cbfed66.map