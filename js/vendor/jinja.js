/**
 * Bundled by jsDelivr using Rollup v2.79.2 and Terser v5.39.0.
 * Original file: /npm/@huggingface/jinja@0.1.2/dist/index.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
var e=Object.freeze({Text:"Text",NumericLiteral:"NumericLiteral",BooleanLiteral:"BooleanLiteral",StringLiteral:"StringLiteral",Identifier:"Identifier",Equals:"Equals",OpenParen:"OpenParen",CloseParen:"CloseParen",OpenStatement:"OpenStatement",CloseStatement:"CloseStatement",OpenExpression:"OpenExpression",CloseExpression:"CloseExpression",OpenSquareBracket:"OpenSquareBracket",CloseSquareBracket:"CloseSquareBracket",Comma:"Comma",Dot:"Dot",Colon:"Colon",Pipe:"Pipe",CallOperator:"CallOperator",AdditiveBinaryOperator:"AdditiveBinaryOperator",MultiplicativeBinaryOperator:"MultiplicativeBinaryOperator",ComparisonBinaryOperator:"ComparisonBinaryOperator",UnaryOperator:"UnaryOperator",Set:"Set",If:"If",For:"For",In:"In",NotIn:"NotIn",Else:"Else",EndIf:"EndIf",ElseIf:"ElseIf",EndFor:"EndFor",And:"And",Or:"Or",Not:"UnaryOperator"}),t=Object.freeze({set:e.Set,for:e.For,in:e.In,if:e.If,else:e.Else,endif:e.EndIf,elif:e.ElseIf,endfor:e.EndFor,and:e.And,or:e.Or,not:e.Not,"not in":e.NotIn,true:e.BooleanLiteral,false:e.BooleanLiteral}),n=class{constructor(e,t){this.value=e,this.type=t}};function r(e){return/\w/.test(e)}function a(e){return/[0-9]/.test(e)}var o=[["{%",e.OpenStatement],["%}",e.CloseStatement],["{{",e.OpenExpression],["}}",e.CloseExpression],["(",e.OpenParen],[")",e.CloseParen],["[",e.OpenSquareBracket],["]",e.CloseSquareBracket],[",",e.Comma],[".",e.Dot],[":",e.Colon],["|",e.Pipe],["<=",e.ComparisonBinaryOperator],[">=",e.ComparisonBinaryOperator],["==",e.ComparisonBinaryOperator],["!=",e.ComparisonBinaryOperator],["<",e.ComparisonBinaryOperator],[">",e.ComparisonBinaryOperator],["+",e.AdditiveBinaryOperator],["-",e.AdditiveBinaryOperator],["*",e.MultiplicativeBinaryOperator],["/",e.MultiplicativeBinaryOperator],["%",e.MultiplicativeBinaryOperator],["=",e.Equals]],s=new Map([["n","\n"],["t","\t"],["r","\r"],["b","\b"],["f","\f"],["v","\v"],["'","'"],['"','"'],["\\","\\"]]);function i(i){const l=[],u=i;let c=0;const p=e=>{let t="";for(;e(u[c]);)if("\\"!==u[c]){if(t+=u[c++],c>=u.length)throw new SyntaxError("Unexpected end of input")}else{if(++c,c>=u.length)throw new SyntaxError("Unexpected end of input");const e=u[c++],n=s.get(e);if(void 0===n)throw new SyntaxError(`Unexpected escaped character: ${e}`);t+=n}return t};e:for(;c<u.length;){const s=l.at(-1)?.type;if(void 0===s||s===e.CloseStatement||s===e.CloseExpression){let t="";for(;c<u.length&&("{"!==u[c]||"%"!==u[c+1]&&"{"!==u[c+1]);)t+=u[c++];if(t.length>0){l.push(new n(t,e.Text));continue}}p((e=>/\s/.test(e)));const i=u[c];if("-"===i||"+"===i){const t=l.at(-1)?.type;if(t===e.Text||void 0===t)throw new SyntaxError(`Unexpected character: ${i}`);switch(t){case e.Identifier:case e.NumericLiteral:case e.BooleanLiteral:case e.StringLiteral:case e.CloseParen:case e.CloseSquareBracket:break;default:{++c;const t=p(a);l.push(new n(`${i}${t}`,t.length>0?e.NumericLiteral:e.UnaryOperator));continue}}}for(const[e,t]of o){if(u.slice(c,c+e.length)===e){l.push(new n(e,t)),c+=e.length;continue e}}if("'"!==i)if(a(i)){const t=p(a);l.push(new n(t,e.NumericLiteral))}else{if(!r(i))throw new SyntaxError(`Unexpected character: ${i}`);{const a=p(r),o=Object.hasOwn(t,a)?t[a]:e.Identifier;o===e.In&&l.at(-1)?.type===e.Not?(l.pop(),l.push(new n("not in",e.NotIn))):l.push(new n(a,o))}}else{++c;const t=p((e=>"'"!==e));l.push(new n(t,e.StringLiteral)),++c}}return l}var l=class{type="Statement"},u=class extends l{constructor(e){super(),this.body=e}type="Program"},c=class extends l{constructor(e,t,n){super(),this.test=e,this.body=t,this.alternate=n}type="If"},p=class extends l{constructor(e,t,n){super(),this.loopvar=e,this.iterable=t,this.body=n}type="For"},f=class extends l{constructor(e,t){super(),this.assignee=e,this.value=t}type="Set"},h=class extends l{type="Expression"},v=class extends h{constructor(e,t,n){super(),this.object=e,this.property=t,this.computed=n}type="MemberExpression"},w=class extends h{constructor(e,t){super(),this.callee=e,this.args=t}type="CallExpression"},d=class extends h{constructor(e){super(),this.value=e}type="Identifier"},y=class extends h{constructor(e){super(),this.value=e}type="Literal"},x=class extends y{type="NumericLiteral"},E=class extends y{type="StringLiteral";constructor(e){super(e)}},m=class extends y{type="BooleanLiteral"},g=class extends h{constructor(e,t,n){super(),this.operator=e,this.left=t,this.right=n}type="BinaryExpression"},S=class extends h{constructor(e,t){super(),this.operand=e,this.filter=t}type="FilterExpression"},b=class extends h{constructor(e,t){super(),this.operator=e,this.argument=t}type="UnaryExpression"},C=class extends h{constructor(e=void 0,t=void 0,n=void 0){super(),this.start=e,this.stop=t,this.step=n}type="SliceExpression"};function O(t){const n=new u([]);let r=0;function a(e,n){const a=t[r++];if(!a||a.type!==e)throw new Error(`Parser Error: ${n}. ${a.type} !== ${e}.`);return a}function o(){switch(t[r].type){case e.Text:return new E(a(e.Text,"Expected text token").value);case e.OpenStatement:return function(){let n;switch(a(e.OpenStatement,"Expected opening statement token"),t[r].type){case e.Set:++r,n=l(),a(e.CloseStatement,"Expected closing statement token");break;case e.If:++r,n=h(),a(e.OpenStatement,"Expected {% token"),a(e.EndIf,"Expected endif token"),a(e.CloseStatement,"Expected %} token");break;case e.For:++r,n=function(){const t=N();if(!(t instanceof d))throw new SyntaxError("Expected identifier for the loop variable");a(e.In,"Expected `in` keyword following loop variable");const n=y();a(e.CloseStatement,"Expected closing statement token");const r=[];for(;s(e.OpenStatement,e.EndFor);)r.push(o());return new p(t,n,r)}(),a(e.OpenStatement,"Expected {% token"),a(e.EndFor,"Expected endfor token"),a(e.CloseStatement,"Expected %} token");break;default:throw new SyntaxError(`Unknown statement type: ${t[r].type}`)}return n}();case e.OpenExpression:return function(){a(e.OpenExpression,"Expected opening expression token");const t=y();return a(e.CloseExpression,"Expected closing expression token"),t}();default:throw new SyntaxError(`Unexpected token type: ${t[r].type}`)}}function s(...e){return r+e.length<=t.length&&e.some(((e,n)=>e!==t[r+n].type))}function i(...e){return r+e.length<=t.length&&e.every(((e,n)=>e===t[r+n].type))}function l(){const t=y();if(i(e.Equals)){++r;const e=l();return new f(t,e)}return t}function h(){const n=y();a(e.CloseStatement,"Expected closing statement token");const s=[],l=[];for(;t[r]?.type!==e.OpenStatement||t[r+1]?.type!==e.ElseIf&&t[r+1]?.type!==e.Else&&t[r+1]?.type!==e.EndIf;)s.push(o());if(t[r]?.type===e.OpenStatement&&t[r+1]?.type!==e.EndIf)if(++r,i(e.ElseIf))a(e.ElseIf,"Expected elseif token"),l.push(h());else for(a(e.Else,"Expected else token"),a(e.CloseStatement,"Expected closing statement token");t[r]?.type!==e.OpenStatement||t[r+1]?.type!==e.EndIf;)l.push(o());return new c(n,s,l)}function y(){return function(){let n=O();for(;i(e.Or);){const e=t[r];++r;const a=O();n=new g(e,n,a)}return n}()}function O(){let n=B();for(;i(e.And);){const e=t[r];++r;const a=B();n=new g(e,n,a)}return n}function B(){let n;for(;i(e.Not);){const e=t[r];++r;const a=B();n=new b(e,a)}return n??function(){let n=k();for(;i(e.ComparisonBinaryOperator)||i(e.In)||i(e.NotIn);){const e=t[r];++r;const a=k();n=new g(e,n,a)}return n}()}function k(){let n=M();for(;i(e.AdditiveBinaryOperator);){const e=t[r];++r;const a=M();n=new g(e,n,a)}return n}function I(){const n=function(){let n=N();for(;i(e.Dot)||i(e.OpenSquareBracket);){const o=t[r];let s;++r;const i=o.type!==e.Dot;if(i)s=L(),a(e.CloseSquareBracket,"Expected closing square bracket");else if(s=N(),"Identifier"!==s.type)throw new SyntaxError("Expected identifier following dot operator");n=new v(n,s,i)}return n}();return i(e.OpenParen)?$(n):n}function $(t){let n=new w(t,function(){a(e.OpenParen,"Expected opening parenthesis for arguments list");const t=i(e.CloseParen)?[]:function(){const t=[y()];for(;i(e.Comma);)++r,t.push(y());return t}();return a(e.CloseParen,"Expected closing parenthesis for arguments list"),t}());return i(e.OpenParen)&&(n=$(n)),n}function L(){const t=[];let n=!1;for(;!i(e.CloseSquareBracket);)i(e.Colon)?(t.push(void 0),++r,n=!0):(t.push(y()),i(e.Colon)&&(++r,n=!0));if(0===t.length)throw new SyntaxError("Expected at least one argument for member/slice expression");if(n){if(t.length>3)throw new SyntaxError("Expected 0-3 arguments for slice expression");return new C(...t)}return t[0]}function M(){let n=_();for(;i(e.MultiplicativeBinaryOperator);){const e=t[r];++r;const a=_();n=new g(e,n,a)}return n}function _(){let t=I();for(;i(e.Pipe);){++r;const e=N();if(!(e instanceof d))throw new SyntaxError("Expected identifier for the filter");t=new S(t,e)}return t}function N(){const n=t[r];switch(n.type){case e.NumericLiteral:return++r,new x(Number(n.value));case e.StringLiteral:return++r,new E(n.value);case e.BooleanLiteral:return++r,new m("true"===n.value);case e.Identifier:return++r,new d(n.value);case e.OpenParen:{++r;const n=y();if(t[r].type!==e.CloseParen)throw new SyntaxError("Expected closing parenthesis");return++r,n}default:throw new SyntaxError(`Unexpected token: ${n.type}`)}}for(;r<t.length;)n.body.push(o());return n}function B(e,t,n,r=1){const a=Math.sign(r);a>=0?(t=(t??=0)<0?Math.max(e.length+t,0):Math.min(t,e.length),n=(n??=e.length)<0?Math.max(e.length+n,0):Math.min(n,e.length)):(t=(t??=e.length-1)<0?Math.max(e.length+t,-1):Math.min(t,e.length-1),n=(n??=-1)<-1?Math.max(e.length+n,-1):Math.min(n,e.length-1));const o=[];for(let s=t;a*s<a*n;s+=r)o.push(e[s]);return o}var k=class{type="RuntimeValue";value;builtins=new Map;constructor(e=void 0){this.value=e}__bool__(){return new L(!!this.value)}},I=class extends k{type="NumericValue"},$=class extends k{type="StringValue";builtins=new Map([["upper",new N((()=>new $(this.value.toUpperCase())))],["lower",new N((()=>new $(this.value.toLowerCase())))],["strip",new N((()=>new $(this.value.trim())))],["length",new I(this.value.length)]])},L=class extends k{type="BooleanValue"},M=class extends k{type="ObjectValue";__bool__(){return new L(this.value.size>0)}},_=class extends k{type="ArrayValue";builtins=new Map([["length",new I(this.value.length)]]);__bool__(){return new L(this.value.length>0)}},N=class extends k{type="FunctionValue"},P=class extends k{type="NullValue"},U=class extends k{type="UndefinedValue"},V=class{constructor(e){this.parent=e}variables=new Map;set(e,t){return this.declareVariable(e,q(t))}declareVariable(e,t){if(this.variables.has(e))throw new SyntaxError(`Variable already declared: ${e}`);return this.variables.set(e,t),t}setVariable(e,t){let n;try{n=this.resolve(e)}catch{}return(n??this).variables.set(e,t),t}resolve(e){if(this.variables.has(e))return this;if(this.parent)return this.parent.resolve(e);throw new Error(`Unknown variable: ${e}`)}lookupVariable(e){return this.resolve(e).variables.get(e)??new P}},F=class{global;constructor(e){this.global=e??new V}run(e){return this.evaluate(e,this.global)}evaluateBinaryExpression(e,t){const n=this.evaluate(e.left,t),r=this.evaluate(e.right,t);switch(e.operator.value){case"==":return new L(n.value==r.value);case"!=":return new L(n.value!=r.value);case"and":return n.__bool__().value?r:n;case"or":return n.__bool__().value?n:r}if(n instanceof U||r instanceof U)throw new Error("Cannot perform operation on undefined values");if(n instanceof P||r instanceof P)throw new Error("Cannot perform operation on null values");if(n instanceof I&&r instanceof I)switch(e.operator.value){case"+":return new I(n.value+r.value);case"-":return new I(n.value-r.value);case"*":return new I(n.value*r.value);case"/":return new I(n.value/r.value);case"%":return new I(n.value%r.value);case"<":return new L(n.value<r.value);case">":return new L(n.value>r.value);case">=":return new L(n.value>=r.value);case"<=":return new L(n.value<=r.value)}else if(r instanceof _){const t=void 0!==r.value.find((e=>e.value===n.value));switch(e.operator.value){case"in":return new L(t);case"not in":return new L(!t)}}if((n instanceof $||r instanceof $)&&"+"===e.operator.value)return new $(n.value.toString()+r.value.toString());if(n instanceof $&&r instanceof $)switch(e.operator.value){case"in":return new L(r.value.includes(n.value));case"not in":return new L(!r.value.includes(n.value))}throw new SyntaxError(`Unknown operator "${e.operator.value}" between ${n.type} and ${r.type}`)}evaluateFilterExpression(e,t){const n=this.evaluate(e.operand,t);if(n instanceof _)switch(e.filter.value){case"first":return n.value[0];case"last":return n.value[n.value.length-1];case"length":return new I(n.value.length);case"reverse":return new _(n.value.reverse());case"sort":return new _(n.value.sort(((e,t)=>{if(e.type!==t.type)throw new Error(`Cannot compare different types: ${e.type} and ${t.type}`);switch(e.type){case"NumericValue":return e.value-t.value;case"StringValue":return e.value.localeCompare(t.value);default:throw new Error(`Cannot compare type: ${e.type}`)}})));default:throw new Error(`Unknown filter: ${e.filter.value}`)}throw new Error(`Cannot apply filter to type: ${n.type}`)}evaluateUnaryExpression(e,t){const n=this.evaluate(e.argument,t);if("not"===e.operator.value)return new L(!n.value);throw new SyntaxError(`Unknown operator: ${e.operator.value}`)}evalProgram(e,t){return this.evaluateBlock(e.body,t)}evaluateBlock(e,t){let n="";for(const r of e){const e=this.evaluate(r,t);"NullValue"!==e.type&&(n+=e.value)}return n=n.replace(/^\n/,""),new $(n)}evaluateIdentifier(e,t){return t.lookupVariable(e.value)}evaluateCallExpression(e,t){const n=e.args.map((e=>this.evaluate(e,t))),r=this.evaluate(e.callee,t);if("FunctionValue"!==r.type)throw new Error(`Cannot call something that is not a function: got ${r.type}`);return r.value(n,t)}evaluateSliceExpression(e,t,n){if(!(e instanceof _||e instanceof $))throw new Error("Slice object must be an array or string");const r=this.evaluate(t.start,n),a=this.evaluate(t.stop,n),o=this.evaluate(t.step,n);if(!(r instanceof I||r instanceof U))throw new Error("Slice start must be numeric or undefined");if(!(a instanceof I||a instanceof U))throw new Error("Slice stop must be numeric or undefined");if(!(o instanceof I||o instanceof U))throw new Error("Slice step must be numeric or undefined");return e instanceof _?new _(B(e.value,r.value,a.value,o.value)):new $(B(Array.from(e.value),r.value,a.value,o.value).join(""))}evaluateMemberExpression(e,t){const n=this.evaluate(e.object,t);let r,a;if(e.computed){if("SliceExpression"===e.property.type)return this.evaluateSliceExpression(n,e.property,t);r=this.evaluate(e.property,t)}else r=new $(e.property.value);if(n instanceof M){if(!(r instanceof $))throw new Error(`Cannot access property with non-string: got ${r.type}`);a=n.value.get(r.value)??n.builtins.get(r.value)}else if(n instanceof _||n instanceof $)if(r instanceof I)a=n.value.at(r.value),n instanceof $&&(a=new $(n.value.at(r.value)));else{if(!(r instanceof $))throw new Error(`Cannot access property with non-string/non-number: got ${r.type}`);a=n.builtins.get(r.value)}else{if(!(r instanceof $))throw new Error(`Cannot access property with non-string: got ${r.type}`);a=n.builtins.get(r.value)}if(!(a instanceof k))throw new Error(`${n.type} has no property '${r.value}'`);return a}evaluateSet(e,t){if("Identifier"!==e.assignee.type)throw new Error(`Invalid LHS inside assignment expression: ${JSON.stringify(e.assignee)}`);const n=e.assignee.value;return t.setVariable(n,this.evaluate(e.value,t)),new P}evaluateIf(e,t){const n=this.evaluate(e.test,t);return this.evaluateBlock(n.__bool__().value?e.body:e.alternate,t)}evaluateFor(e,t){const n=new V(t),r=this.evaluate(e.iterable,n);if(!(r instanceof _))throw new Error(`Expected iterable type in for loop: got ${r.type}`);let a="";for(let t=0;t<r.value.length;++t){n.setVariable("loop",new M(new Map([["index",new I(t+1)],["index0",new I(t)],["first",new L(0===t)],["last",new L(t===r.value.length-1)],["length",new I(r.value.length)]].map((([e,t])=>[e,t]))))),n.setVariable(e.loopvar.value,r.value[t]);a+=this.evaluateBlock(e.body,n).value}return new $(a)}evaluate(e,t){if(void 0===e)return new U;switch(e.type){case"Program":return this.evalProgram(e,t);case"Set":return this.evaluateSet(e,t);case"If":return this.evaluateIf(e,t);case"For":return this.evaluateFor(e,t);case"NumericLiteral":return new I(Number(e.value));case"StringLiteral":return new $(e.value);case"BooleanLiteral":return new L(e.value);case"Identifier":return this.evaluateIdentifier(e,t);case"CallExpression":return this.evaluateCallExpression(e,t);case"MemberExpression":return this.evaluateMemberExpression(e,t);case"UnaryExpression":return this.evaluateUnaryExpression(e,t);case"BinaryExpression":return this.evaluateBinaryExpression(e,t);case"FilterExpression":return this.evaluateFilterExpression(e,t);default:throw new SyntaxError(`Unknown node type: ${e.type}`)}}};function q(e){switch(typeof e){case"number":return new I(e);case"string":return new $(e);case"boolean":return new L(e);case"object":return null===e?new P:Array.isArray(e)?new _(e.map(q)):new M(new Map(Object.entries(e).map((([e,t])=>[e,q(t)]))));case"function":return new N(((t,n)=>q(e(...t.map((e=>e.value)))??null)));default:throw new Error(`Cannot convert to runtime value: ${e}`)}}var A=class{parsed;constructor(e){const t=i(e=e.replace(/%}\s+{%/g,"%}{%"));this.parsed=O(t)}render(e){const t=new V;t.set("false",!1),t.set("true",!0),t.set("raise_exception",(e=>{throw new Error(e)}));for(const[n,r]of Object.entries(e))t.set(n,r);return new F(t).run(this.parsed).value}};export{V as Environment,F as Interpreter,A as Template,O as parse,i as tokenize};export default null;
//# sourceMappingURL=/sm/d33fea6c1e3534fca18e284bb9155b8b31e1c38f3e2816594925731ba9fdbf6f.map