/**
 * Bundled by jsDelivr using Rollup v2.79.2 and Terser v5.39.0.
 * Original file: /npm/onnxruntime-common@1.14.0/dist/lib/index.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
const t = {}, e = [], r = (r, n, i) => { if (!n || "function" != typeof n.init || "function" != typeof n.createSessionHandler) throw new TypeError("not a valid backend"); { const o = t[r]; if (void 0 === o) t[r] = { backend: n, priority: i }; else { if (o.priority > i) return; if (o.priority === i && o.backend !== n) throw new Error(`cannot register backend "${r}" using priority ${i}`) } if (i >= 0) { const n = e.indexOf(r); -1 !== n && e.splice(n, 1); for (let n = 0; n < e.length; n++)if (t[e[n]].priority <= i) return void e.splice(n, 0, r); e.push(r) } } }; const n = new class { constructor() { this.wasm = {}, this.webgl = {}, this.logLevelInternal = "warning" } set logLevel(t) { if (void 0 !== t) { if ("string" != typeof t || -1 === ["verbose", "info", "warning", "error", "fatal"].indexOf(t)) throw new Error(`Unsupported logging level: ${t}`); this.logLevelInternal = t } } get logLevel() { return this.logLevelInternal } }, i = "undefined" != typeof BigInt64Array && "function" == typeof BigInt64Array.from, o = "undefined" != typeof BigUint64Array && "function" == typeof BigUint64Array.from, a = new Map([["float32", Float32Array], ["uint8", Uint8Array], ["int8", Int8Array], ["uint16", Uint16Array], ["int16", Int16Array], ["int32", Int32Array], ["bool", Uint8Array], ["float64", Float64Array], ["uint32", Uint32Array]]), s = new Map([[Float32Array, "float32"], [Uint8Array, "uint8"], [Int8Array, "int8"], [Uint16Array, "uint16"], [Int16Array, "int16"], [Int32Array, "int32"], [Float64Array, "float64"], [Uint32Array, "uint32"]]); i && (a.set("int64", BigInt64Array), s.set(BigInt64Array, "int64")), o && (a.set("uint64", BigUint64Array), s.set(BigUint64Array, "uint64")); class h { constructor(t, e, r) { let n, i, o; if ("string" == typeof t) if (n = t, o = r, "string" === t) { if (!Array.isArray(e)) throw new TypeError("A string tensor's data must be a string array."); i = e } else { const r = a.get(t); if (void 0 === r) throw new TypeError(`Unsupported tensor type: ${t}.`); if (Array.isArray(e)) i = r.from(e); else { if (!(e instanceof r)) throw new TypeError(`A ${n} tensor's data must be type of ${r}`); i = e } } else if (o = e, Array.isArray(t)) { if (0 === t.length) throw new TypeError("Tensor type cannot be inferred from an empty array."); const e = typeof t[0]; if ("string" === e) n = "string", i = t; else { if ("boolean" !== e) throw new TypeError(`Invalid element type of data array: ${e}.`); n = "bool", i = Uint8Array.from(t) } } else { const e = s.get(t.constructor); if (void 0 === e) throw new TypeError(`Unsupported type for tensor data: ${t.constructor}.`); n = e, i = t } if (void 0 === o) o = [i.length]; else if (!Array.isArray(o)) throw new TypeError("A tensor's dims must be a number array"); const h = (t => { let e = 1; for (let r = 0; r < t.length; r++) { const n = t[r]; if ("number" != typeof n || !Number.isSafeInteger(n)) throw new TypeError(`dims[${r}] must be an integer, got: ${n}`); if (n < 0) throw new RangeError(`dims[${r}] must be a non-negative integer, got: ${n}`); e *= n } return e })(o); if (h !== i.length) throw new Error(`Tensor's size(${h}) does not match data length(${i.length}).`); this.dims = o, this.type = n, this.data = i, this.size = h } static bufferToTensor(t, e) { if (void 0 === t) throw new Error("Image buffer must be defined"); if (void 0 === e.height || void 0 === e.width) throw new Error("Image height and width must be defined"); const { height: r, width: n } = e, i = e.norm; let o, a; o = void 0 === i || void 0 === i.mean ? 255 : i.mean, a = void 0 === i || void 0 === i.bias ? 0 : i.bias; const s = void 0 !== e.bitmapFormat ? e.bitmapFormat : "RGBA", f = void 0 !== e.tensorFormat && void 0 !== e.tensorFormat ? e.tensorFormat : "RGB", d = r * n, g = "RGBA" === f ? new Float32Array(4 * d) : new Float32Array(3 * d); let m = 4, c = 0, w = 1, l = 2, u = 3, p = 0, y = d, b = 2 * d, v = -1; "RGB" === s && (m = 3, c = 0, w = 1, l = 2, u = -1), "RGBA" === f ? v = 3 * d : "RBG" === f ? (p = 0, b = d, y = 2 * d) : "BGR" === f && (b = 0, y = d, p = 2 * d); for (let e = 0; e < d; e++, c += m, l += m, w += m, u += m)g[p++] = (t[c] + a) / o, g[y++] = (t[w] + a) / o, g[b++] = (t[l] + a) / o, -1 !== v && -1 !== u && (g[v++] = (t[u] + a) / o); return new h("float32", g, "RGBA" === f ? [1, 4, r, n] : [1, 3, r, n]) } static async fromImage(t, e) { const r = "undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement, n = "undefined" != typeof ImageData && t instanceof ImageData, i = "undefined" != typeof ImageBitmap && t instanceof ImageBitmap, o = "undefined" != typeof String && (t instanceof String || "string" == typeof t); let a, s = {}; if (r) { const r = document.createElement("canvas"), n = r.getContext("2d"); if (null == n) throw new Error("Can not access image data"); { let i = t.naturalHeight, o = t.naturalWidth; if (void 0 !== e && void 0 !== e.resizedHeight && void 0 !== e.resizedWidth && (i = e.resizedHeight, o = e.resizedWidth), void 0 !== e) { if (s = e, void 0 !== e.tensorFormat) throw new Error("Image input config format must be RGBA for HTMLImageElement"); if (s.tensorFormat = "RGBA", void 0 !== e.height && e.height !== i) throw new Error("Image input config height doesn't match HTMLImageElement height"); if (s.height = i, void 0 !== e.width && e.width !== o) throw new Error("Image input config width doesn't match HTMLImageElement width"); s.width = o } else s.tensorFormat = "RGBA", s.height = i, s.width = o; r.width = o, r.height = i, n.drawImage(t, 0, 0, o, i), a = n.getImageData(0, 0, o, i).data } } else { if (!n) { if (i) { if (void 0 === e) throw new Error("Please provide image config with format for Imagebitmap"); if (void 0 !== e.bitmapFormat) throw new Error("Image input config format must be defined for ImageBitmap"); const r = document.createElement("canvas").getContext("2d"); if (null != r) { const n = t.height, i = t.width; if (r.drawImage(t, 0, 0, i, n), a = r.getImageData(0, 0, i, n).data, void 0 !== e) { if (void 0 !== e.height && e.height !== n) throw new Error("Image input config height doesn't match ImageBitmap height"); if (s.height = n, void 0 !== e.width && e.width !== i) throw new Error("Image input config width doesn't match ImageBitmap width"); s.width = i } else s.height = n, s.width = i; return h.bufferToTensor(a, s) } throw new Error("Can not access image data") } if (o) return new Promise(((r, n) => { const i = document.createElement("canvas"), o = i.getContext("2d"); if (!t || !o) return n(); const a = new Image; a.crossOrigin = "Anonymous", a.src = t, a.onload = () => { i.width = a.width, i.height = a.height, o.drawImage(a, 0, 0, i.width, i.height); const t = o.getImageData(0, 0, i.width, i.height); if (void 0 !== e) { if (void 0 !== e.height && e.height !== i.height) throw new Error("Image input config height doesn't match ImageBitmap height"); if (s.height = i.height, void 0 !== e.width && e.width !== i.width) throw new Error("Image input config width doesn't match ImageBitmap width"); s.width = i.width } else s.height = i.height, s.width = i.width; r(h.bufferToTensor(t.data, s)) } })); throw new Error("Input data provided is not supported - aborted tensor creation") } { const r = "RGBA"; let n, i; if (void 0 !== e && void 0 !== e.resizedWidth && void 0 !== e.resizedHeight ? (n = e.resizedHeight, i = e.resizedWidth) : (n = t.height, i = t.width), void 0 !== e) { if (s = e, void 0 !== e.bitmapFormat && e.bitmapFormat !== r) throw new Error("Image input config format must be RGBA for ImageData"); s.bitmapFormat = "RGBA" } else s.bitmapFormat = "RGBA"; if (s.height = n, s.width = i, void 0 !== e) { const e = document.createElement("canvas"); e.width = i, e.height = n; const r = e.getContext("2d"); if (null == r) throw new Error("Can not access image data"); r.putImageData(t, 0, 0), a = r.getImageData(0, 0, i, n).data } else a = t.data } } if (void 0 !== a) return h.bufferToTensor(a, s); throw new Error("Input data provided is not supported - aborted tensor creation") } toImageData(t) { var e, r; const n = document.createElement("canvas").getContext("2d"); let i; if (null == n) throw new Error("Can not access image data"); { const o = this.dims[3], a = this.dims[2], s = this.dims[1], h = void 0 !== t && void 0 !== t.format ? t.format : "RGB", f = void 0 !== t && void 0 !== (null === (e = t.norm) || void 0 === e ? void 0 : e.mean) ? t.norm.mean : 255, d = void 0 !== t && void 0 !== (null === (r = t.norm) || void 0 === r ? void 0 : r.bias) ? t.norm.bias : 0, g = a * o; if (void 0 !== t) { if (void 0 !== t.height && t.height !== a) throw new Error("Image output config height doesn't match tensor height"); if (void 0 !== t.width && t.width !== o) throw new Error("Image output config width doesn't match tensor width"); if (void 0 !== t.format && 4 === s && "RGBA" !== t.format || 3 === s && "RGB" !== t.format && "BGR" !== t.format) throw new Error("Tensor format doesn't match input tensor dims") } const m = 4; let c = 0, w = 1, l = 2, u = 3, p = 0, y = g, b = 2 * g, v = -1; "RGBA" === h ? (p = 0, y = g, b = 2 * g, v = 3 * g) : "RGB" === h ? (p = 0, y = g, b = 2 * g) : "RBG" === h && (p = 0, b = g, y = 2 * g), i = n.createImageData(o, a); for (let t = 0; t < a * o; c += m, w += m, l += m, u += m, t++)i.data[c] = (this.data[p++] - d) * f, i.data[w] = (this.data[y++] - d) * f, i.data[l] = (this.data[b++] - d) * f, i.data[u] = -1 === v ? 255 : (this.data[v++] - d) * f } return i } reshape(t) { return new h(this.type, this.data, t) } } const f = h; class d { constructor(t) { this.handler = t } async run(t, e, r) { const n = {}; let i = {}; if ("object" != typeof t || null === t || t instanceof f || Array.isArray(t)) throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values."); let o = !0; if ("object" == typeof e) { if (null === e) throw new TypeError("Unexpected argument[1]: cannot be null."); if (e instanceof f) throw new TypeError("'fetches' cannot be a Tensor"); if (Array.isArray(e)) { if (0 === e.length) throw new TypeError("'fetches' cannot be an empty array."); o = !1; for (const t of e) { if ("string" != typeof t) throw new TypeError("'fetches' must be a string array or an object."); if (-1 === this.outputNames.indexOf(t)) throw new RangeError(`'fetches' contains invalid output name: ${t}.`); n[t] = null } if ("object" == typeof r && null !== r) i = r; else if (void 0 !== r) throw new TypeError("'options' must be an object.") } else { let t = !1; const a = Object.getOwnPropertyNames(e); for (const r of this.outputNames) if (-1 !== a.indexOf(r)) { const i = e[r]; (null === i || i instanceof f) && (t = !0, o = !1, n[r] = i) } if (t) { if ("object" == typeof r && null !== r) i = r; else if (void 0 !== r) throw new TypeError("'options' must be an object.") } else i = e } } else if (void 0 !== e) throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'."); for (const e of this.inputNames) if (void 0 === t[e]) throw new Error(`input '${e}' is missing in 'feeds'.`); if (o) for (const t of this.outputNames) n[t] = null; const a = await this.handler.run(t, n, i), s = {}; for (const t in a) Object.hasOwnProperty.call(a, t) && (s[t] = new f(a[t].type, a[t].data, a[t].dims)); return s } static async create(r, n, i, o) { let a, s = {}; if ("string" == typeof r) { if (a = r, "object" == typeof n && null !== n) s = n; else if (void 0 !== n) throw new TypeError("'options' must be an object.") } else if (r instanceof Uint8Array) { if (a = r, "object" == typeof n && null !== n) s = n; else if (void 0 !== n) throw new TypeError("'options' must be an object.") } else { if (!(r instanceof ArrayBuffer || "undefined" != typeof SharedArrayBuffer && r instanceof SharedArrayBuffer)) throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'."); { const t = r; let e = 0, h = r.byteLength; if ("object" == typeof n && null !== n) s = n; else if ("number" == typeof n) { if (e = n, !Number.isSafeInteger(e)) throw new RangeError("'byteOffset' must be an integer."); if (e < 0 || e >= t.byteLength) throw new RangeError(`'byteOffset' is out of range [0, ${t.byteLength}).`); if (h = r.byteLength - e, "number" == typeof i) { if (h = i, !Number.isSafeInteger(h)) throw new RangeError("'byteLength' must be an integer."); if (h <= 0 || e + h > t.byteLength) throw new RangeError(`'byteLength' is out of range (0, ${t.byteLength - e}].`); if ("object" == typeof o && null !== o) s = o; else if (void 0 !== o) throw new TypeError("'options' must be an object.") } else if (void 0 !== i) throw new TypeError("'byteLength' must be a number.") } else if (void 0 !== n) throw new TypeError("'options' must be an object."); a = new Uint8Array(t, e, h) } } const h = (s.executionProviders || []).map((t => "string" == typeof t ? t : t.name)), f = await (async r => { const n = 0 === r.length ? e : r, i = []; for (const e of n) { const r = t[e]; if (r) { if (r.initialized) return r.backend; if (r.aborted) continue; const t = !!r.initPromise; try { return t || (r.initPromise = r.backend.init()), await r.initPromise, r.initialized = !0, r.backend } catch (n) { t || i.push({ name: e, err: n }), r.aborted = !0 } finally { delete r.initPromise } } } throw new Error(`no available backend found. ERR: ${i.map((t => `[${t.name}] ${t.err}`)).join(", ")}`) })(h), g = await f.createSessionHandler(a, s); return new d(g) } startProfiling() { this.handler.startProfiling() } endProfiling() { this.handler.endProfiling() } get inputNames() { return this.handler.inputNames } get outputNames() { return this.handler.outputNames } } const g = d; const ort = { InferenceSession: g, Tensor: f, env: n, registerBackend: r }; export { g as InferenceSession, f as Tensor, n as env, r as registerBackend }; export default ort;
//# sourceMappingURL=/sm/52b0f727994cb681afa29203f390eb7cd4221d4f2e9ca38ccbde157c2c0b466b.map